/**
 * TAP Agent implementation based on the Transaction Authorization Protocol specification
 * 
 * @module TAPAgent
 */

import { TapError, ErrorType } from "./error.ts";
import { wasmLoader } from "./wasm/loader.ts";
import { TAPMessage, TAPMessageType, TAPMessageHandler } from "./TAPMessage.ts";
import type { DID } from "../../prds/taips/packages/typescript/src/tap";

/**
 * TAP Agent configuration options
 */
export interface TAPAgentOptions {
  /** Agent's DID */
  did?: DID;
  
  /** Optional agent nickname */
  nickname?: string;
  
  /** Debug mode flag */
  debug?: boolean;
  
  /** Initial keys for signing */
  keys?: {
    privateKeyJwk?: Record<string, unknown>;
    publicKeyJwk?: Record<string, unknown>;
  };
}

/**
 * TAP Agent class
 * 
 * Represents an agent in the TAP ecosystem and provides functionality
 * for creating, signing, sending, and receiving TAP messages.
 */
export class TAPAgent {
  private wasmAgent: any;
  private did: DID;
  private nickname?: string;
  private debug: boolean;
  private messageHandlers: Map<TAPMessageType, TAPMessageHandler[]> = new Map();
  private globalHandlers: TAPMessageHandler[] = [];
  
  /**
   * Create a new TAP agent
   * 
   * @param options Agent configuration options
   */
  constructor(options: TAPAgentOptions = {}) {
    if (!wasmLoader.moduleIsLoaded()) {
      throw new TapError({
        type: ErrorType.WASM_NOT_LOADED,
        message: "WASM module not loaded",
      });
    }
    
    // Get the WASM module
    const module = wasmLoader.getModule();
    
    this.debug = options.debug ?? false;
    this.nickname = options.nickname;
    
    // Create the WASM agent
    const config = new module.AgentConfig(options.did);
    this.wasmAgent = new module.Agent(config);
    
    // Get the agent's DID (either the one provided or generated by WASM)
    this.did = (options.did || this.wasmAgent.get_did()) as DID;
    
    // Set up keys if provided
    if (options.keys) {
      this.setupKeys(options.keys);
    }
    
    if (this.debug) {
      console.log(`TAPAgent initialized with DID: ${this.did}`);
    }
  }
  
  /**
   * Set up keys for the agent
   * 
   * @param keys Keys to set up
   */
  private setupKeys(keys: { privateKeyJwk?: Record<string, unknown>; publicKeyJwk?: Record<string, unknown> }): void {
    // This is a placeholder for future key setup functionality
    // The actual implementation will depend on the WASM bindings
    if (this.debug) {
      console.log("Setting up keys for agent");
    }
  }
  
  /**
   * Get the agent's DID
   * 
   * @returns The agent's DID
   */
  getDID(): DID {
    return this.did;
  }
  
  /**
   * Get the agent's nickname
   * 
   * @returns The agent's nickname or undefined if not set
   */
  getNickname(): string | undefined {
    return this.nickname;
  }
  
  /**
   * Create a new TAP message
   * 
   * @param type Message type
   * @param options Additional message options
   * @returns A new TAP message with this agent as the sender
   */
  createMessage(type: TAPMessageType, options: Record<string, unknown> = {}): TAPMessage {
    const message = new TAPMessage({
      type,
      from: this.did,
      ...options,
    });
    
    return message;
  }
  
  /**
   * Sign a TAP message
   * 
   * @param message Message to sign
   * @returns The signed message
   */
  signMessage(message: TAPMessage): TAPMessage {
    if (this.debug) {
      console.log(`Signing message (${message.type}) with DID: ${this.did}`);
    }
    
    return message.sign(this.wasmAgent);
  }
  
  /**
   * Verify a TAP message signature
   * 
   * @param message Message to verify
   * @returns True if the signature is valid, false otherwise
   */
  verifyMessage(message: TAPMessage): boolean {
    return message.verify();
  }
  
  /**
   * Process a received message
   * 
   * @param message Message to process
   * @param metadata Optional message metadata
   */
  async processMessage(message: TAPMessage, metadata: Record<string, unknown> = {}): Promise<void> {
    if (this.debug) {
      console.log(`Processing message (${message.type}) from ${message.from || 'unknown'}`);
    }
    
    // Call type-specific handlers
    const typeHandlers = this.messageHandlers.get(message.type);
    if (typeHandlers) {
      for (const handler of typeHandlers) {
        try {
          await handler(message, metadata);
        } catch (error) {
          console.error(`Error in message handler for type ${message.type}:`, error);
        }
      }
    }
    
    // Call global handlers
    for (const handler of this.globalHandlers) {
      try {
        await handler(message, metadata);
      } catch (error) {
        console.error("Error in global message handler:", error);
      }
    }
  }
  
  /**
   * Register a handler for a specific message type
   * 
   * @param type Message type to handle
   * @param handler Handler function
   * @returns This agent for chaining
   */
  handleMessage(type: TAPMessageType, handler: TAPMessageHandler): this {
    if (!this.messageHandlers.has(type)) {
      this.messageHandlers.set(type, []);
    }
    
    this.messageHandlers.get(type)!.push(handler);
    
    if (this.debug) {
      console.log(`Registered handler for message type: ${type}`);
    }
    
    return this;
  }
  
  /**
   * Register a handler for all message types
   * 
   * @param handler Handler function
   * @returns This agent for chaining
   */
  handleAllMessages(handler: TAPMessageHandler): this {
    this.globalHandlers.push(handler);
    
    if (this.debug) {
      console.log("Registered global message handler");
    }
    
    return this;
  }
  
  /**
   * Send a message (asynchronous)
   * 
   * @param message Message to send
   * @param options Sending options (transport-specific)
   * @returns Promise resolving when the message is sent
   */
  async sendMessage(message: TAPMessage, options: Record<string, unknown> = {}): Promise<void> {
    if (!message.from) {
      // Set this agent as the sender if not already set
      message.from = this.did;
    }
    
    if (this.debug) {
      console.log(`Sending message (${message.type}) to ${message.to ? message.to.join(', ') : 'unknown'}`);
    }
    
    // In a real implementation, this would use a transport layer to send the message
    // This is a placeholder for future implementation
    
    // In some cases, we might want to sign the message before sending
    if (options.sign === true) {
      this.signMessage(message);
    }
    
    return Promise.resolve();
  }
}

/**
 * Create a new TAP agent with a random DID
 * 
 * @param options Optional configuration options
 * @returns A new TAP agent
 */
export function createTAPAgent(options: Partial<TAPAgentOptions> = {}): TAPAgent {
  // Generate a DID if not provided
  if (!options.did) {
    const module = wasmLoader.getModule();
    const didKey = module.create_did_key();
    
    options.did = didKey.did as DID;
  }
  
  return new TAPAgent(options as TAPAgentOptions);
}